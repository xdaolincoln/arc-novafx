"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openapi-fetch";
exports.ids = ["vendor-chunks/openapi-fetch"];
exports.modules = {

/***/ "(ssr)/./node_modules/openapi-fetch/dist/cjs/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/openapi-fetch/dist/cjs/index.cjs ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.js\nvar index_exports = {};\n__export(index_exports, {\n  createFinalURL: () => createFinalURL,\n  createPathBasedClient: () => createPathBasedClient,\n  createQuerySerializer: () => createQuerySerializer,\n  default: () => createClient,\n  defaultBodySerializer: () => defaultBodySerializer,\n  defaultPathSerializer: () => defaultPathSerializer,\n  mergeHeaders: () => mergeHeaders,\n  randomID: () => randomID,\n  removeTrailingSlash: () => removeTrailingSlash,\n  serializeArrayParam: () => serializeArrayParam,\n  serializeObjectParam: () => serializeObjectParam,\n  serializePrimitiveParam: () => serializePrimitiveParam,\n  wrapAsPathBasedClient: () => wrapAsPathBasedClient\n});\nmodule.exports = __toCommonJS(index_exports);\nvar PATH_PARAM_RE = /\\{[^{}]+\\}/g;\nvar supportsRequestInitExt = () => {\n  return typeof process === \"object\" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;\n};\nfunction randomID() {\n  return Math.random().toString(36).slice(2, 11);\n}\nfunction createClient(clientOptions) {\n  let {\n    baseUrl = \"\",\n    Request: CustomRequest = globalThis.Request,\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    headers: baseHeaders,\n    requestInitExt = void 0,\n    ...baseOptions\n  } = { ...clientOptions };\n  requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;\n  baseUrl = removeTrailingSlash(baseUrl);\n  const middlewares = [];\n  async function coreFetch(schemaPath, fetchOptions) {\n    const {\n      baseUrl: localBaseUrl,\n      fetch = baseFetch,\n      Request = CustomRequest,\n      headers,\n      params = {},\n      parseAs = \"json\",\n      querySerializer: requestQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      body,\n      ...init\n    } = fetchOptions || {};\n    let finalBaseUrl = baseUrl;\n    if (localBaseUrl) {\n      finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;\n    }\n    let querySerializer = typeof globalQuerySerializer === \"function\" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);\n    if (requestQuerySerializer) {\n      querySerializer = typeof requestQuerySerializer === \"function\" ? requestQuerySerializer : createQuerySerializer({\n        ...typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {},\n        ...requestQuerySerializer\n      });\n    }\n    const serializedBody = body === void 0 ? void 0 : bodySerializer(\n      body,\n      // Note: we declare mergeHeaders() both here and below because it’s a bit of a chicken-or-egg situation:\n      // bodySerializer() needs all headers so we aren’t dropping ones set by the user, however,\n      // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,\n      // setting the content-type at the very beginning to be overwritten.\n      // Lastly, based on the way headers work, it’s not a simple “present-or-not” check becauase null intentionally un-sets headers.\n      mergeHeaders(baseHeaders, headers, params.header)\n    );\n    const finalHeaders = mergeHeaders(\n      // with no body, we should not to set Content-Type\n      serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n      serializedBody instanceof FormData ? {} : {\n        \"Content-Type\": \"application/json\"\n      },\n      baseHeaders,\n      headers,\n      params.header\n    );\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      body: serializedBody,\n      headers: finalHeaders\n    };\n    let id;\n    let options;\n    let request = new CustomRequest(\n      createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),\n      requestInit\n    );\n    let response;\n    for (const key in init) {\n      if (!(key in request)) {\n        request[key] = init[key];\n      }\n    }\n    if (middlewares.length) {\n      id = randomID();\n      options = Object.freeze({\n        baseUrl: finalBaseUrl,\n        fetch,\n        parseAs,\n        querySerializer,\n        bodySerializer\n      });\n      for (const m of middlewares) {\n        if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n          const result = await m.onRequest({\n            request,\n            schemaPath,\n            params,\n            options,\n            id\n          });\n          if (result) {\n            if (result instanceof CustomRequest) {\n              request = result;\n            } else if (result instanceof Response) {\n              response = result;\n              break;\n            } else {\n              throw new Error(\"onRequest: must return new Request() or Response() when modifying the request\");\n            }\n          }\n        }\n      }\n    }\n    if (!response) {\n      try {\n        response = await fetch(request, requestInitExt);\n      } catch (error2) {\n        let errorAfterMiddleware = error2;\n        if (middlewares.length) {\n          for (let i = middlewares.length - 1; i >= 0; i--) {\n            const m = middlewares[i];\n            if (m && typeof m === \"object\" && typeof m.onError === \"function\") {\n              const result = await m.onError({\n                request,\n                error: errorAfterMiddleware,\n                schemaPath,\n                params,\n                options,\n                id\n              });\n              if (result) {\n                if (result instanceof Response) {\n                  errorAfterMiddleware = void 0;\n                  response = result;\n                  break;\n                }\n                if (result instanceof Error) {\n                  errorAfterMiddleware = result;\n                  continue;\n                }\n                throw new Error(\"onError: must return new Response() or instance of Error\");\n              }\n            }\n          }\n        }\n        if (errorAfterMiddleware) {\n          throw errorAfterMiddleware;\n        }\n      }\n      if (middlewares.length) {\n        for (let i = middlewares.length - 1; i >= 0; i--) {\n          const m = middlewares[i];\n          if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n            const result = await m.onResponse({\n              request,\n              response,\n              schemaPath,\n              params,\n              options,\n              id\n            });\n            if (result) {\n              if (!(result instanceof Response)) {\n                throw new Error(\"onResponse: must return new Response() when modifying the response\");\n              }\n              response = result;\n            }\n          }\n        }\n      }\n    }\n    if (response.status === 204 || request.method === \"HEAD\" || response.headers.get(\"Content-Length\") === \"0\") {\n      return response.ok ? { data: void 0, response } : { error: void 0, response };\n    }\n    if (response.ok) {\n      if (parseAs === \"stream\") {\n        return { data: response.body, response };\n      }\n      return { data: await response[parseAs](), response };\n    }\n    let error = await response.text();\n    try {\n      error = JSON.parse(error);\n    } catch {\n    }\n    return { error, response };\n  }\n  return {\n    request(method, url, init) {\n      return coreFetch(url, { ...init, method: method.toUpperCase() });\n    },\n    /** Call a GET endpoint */\n    GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n    /** Register middleware */\n    use(...middleware) {\n      for (const m of middleware) {\n        if (!m) {\n          continue;\n        }\n        if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m || \"onError\" in m)) {\n          throw new Error(\"Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`\");\n        }\n        middlewares.push(m);\n      }\n    },\n    /** Unregister middleware */\n    eject(...middleware) {\n      for (const m of middleware) {\n        const i = middlewares.indexOf(m);\n        if (i !== -1) {\n          middlewares.splice(i, 1);\n        }\n      }\n    }\n  };\n}\nvar PathCallForwarder = class {\n  constructor(client, url) {\n    this.client = client;\n    this.url = url;\n  }\n  GET = (init) => {\n    return this.client.GET(this.url, init);\n  };\n  PUT = (init) => {\n    return this.client.PUT(this.url, init);\n  };\n  POST = (init) => {\n    return this.client.POST(this.url, init);\n  };\n  DELETE = (init) => {\n    return this.client.DELETE(this.url, init);\n  };\n  OPTIONS = (init) => {\n    return this.client.OPTIONS(this.url, init);\n  };\n  HEAD = (init) => {\n    return this.client.HEAD(this.url, init);\n  };\n  PATCH = (init) => {\n    return this.client.PATCH(this.url, init);\n  };\n  TRACE = (init) => {\n    return this.client.TRACE(this.url, init);\n  };\n};\nvar PathClientProxyHandler = class {\n  constructor() {\n    this.client = null;\n  }\n  // Assume the property is an URL.\n  get(coreClient, url) {\n    const forwarder = new PathCallForwarder(coreClient, url);\n    this.client[url] = forwarder;\n    return forwarder;\n  }\n};\nfunction wrapAsPathBasedClient(coreClient) {\n  const handler = new PathClientProxyHandler();\n  const proxy = new Proxy(coreClient, handler);\n  function Client() {\n  }\n  Client.prototype = proxy;\n  const client = new Client();\n  handler.client = client;\n  return client;\n}\nfunction createPathBasedClient(clientOptions) {\n  return wrapAsPathBasedClient(createClient(clientOptions));\n}\nfunction serializePrimitiveParam(name, value, options) {\n  if (value === void 0 || value === null) {\n    return \"\";\n  }\n  if (typeof value === \"object\") {\n    throw new Error(\n      \"Deeply-nested arrays/objects aren\\u2019t supported. Provide your own `querySerializer()` to handle these.\"\n    );\n  }\n  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\nfunction serializeObjectParam(name, value, options) {\n  if (!value || typeof value !== \"object\") {\n    return \"\";\n  }\n  const values = [];\n  const joiner = {\n    simple: \",\",\n    label: \".\",\n    matrix: \";\"\n  }[options.style] || \"&\";\n  if (options.style !== \"deepObject\" && options.explode === false) {\n    for (const k in value) {\n      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n    }\n    const final2 = values.join(\",\");\n    switch (options.style) {\n      case \"form\": {\n        return `${name}=${final2}`;\n      }\n      case \"label\": {\n        return `.${final2}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final2}`;\n      }\n      default: {\n        return final2;\n      }\n    }\n  }\n  for (const k in value) {\n    const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n    values.push(serializePrimitiveParam(finalName, value[k], options));\n  }\n  const final = values.join(joiner);\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\nfunction serializeArrayParam(name, value, options) {\n  if (!Array.isArray(value)) {\n    return \"\";\n  }\n  if (options.explode === false) {\n    const joiner2 = { form: \",\", spaceDelimited: \"%20\", pipeDelimited: \"|\" }[options.style] || \",\";\n    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner2);\n    switch (options.style) {\n      case \"simple\": {\n        return final;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      // case \"spaceDelimited\":\n      // case \"pipeDelimited\":\n      default: {\n        return `${name}=${final}`;\n      }\n    }\n  }\n  const joiner = { simple: \",\", label: \".\", matrix: \";\" }[options.style] || \"&\";\n  const values = [];\n  for (const v of value) {\n    if (options.style === \"simple\" || options.style === \"label\") {\n      values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n    } else {\n      values.push(serializePrimitiveParam(name, v, options));\n    }\n  }\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${values.join(joiner)}` : values.join(joiner);\n}\nfunction createQuerySerializer(options) {\n  return function querySerializer(queryParams) {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === void 0 || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            continue;\n          }\n          search.push(\n            serializeArrayParam(name, value, {\n              style: \"form\",\n              explode: true,\n              ...options?.array,\n              allowReserved: options?.allowReserved || false\n            })\n          );\n          continue;\n        }\n        if (typeof value === \"object\") {\n          search.push(\n            serializeObjectParam(name, value, {\n              style: \"deepObject\",\n              explode: true,\n              ...options?.object,\n              allowReserved: options?.allowReserved || false\n            })\n          );\n          continue;\n        }\n        search.push(serializePrimitiveParam(name, value, options));\n      }\n    }\n    return search.join(\"&\");\n  };\n}\nfunction defaultPathSerializer(pathname, pathParams) {\n  let nextURL = pathname;\n  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {\n    let name = match.substring(1, match.length - 1);\n    let explode = false;\n    let style = \"simple\";\n    if (name.endsWith(\"*\")) {\n      explode = true;\n      name = name.substring(0, name.length - 1);\n    }\n    if (name.startsWith(\".\")) {\n      style = \"label\";\n      name = name.substring(1);\n    } else if (name.startsWith(\";\")) {\n      style = \"matrix\";\n      name = name.substring(1);\n    }\n    if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {\n      continue;\n    }\n    const value = pathParams[name];\n    if (Array.isArray(value)) {\n      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));\n      continue;\n    }\n    if (typeof value === \"object\") {\n      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));\n      continue;\n    }\n    if (style === \"matrix\") {\n      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n      continue;\n    }\n    nextURL = nextURL.replace(match, style === \"label\" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));\n  }\n  return nextURL;\n}\nfunction defaultBodySerializer(body, headers) {\n  if (body instanceof FormData) {\n    return body;\n  }\n  if (headers) {\n    const contentType = headers.get instanceof Function ? headers.get(\"Content-Type\") ?? headers.get(\"content-type\") : headers[\"Content-Type\"] ?? headers[\"content-type\"];\n    if (contentType === \"application/x-www-form-urlencoded\") {\n      return new URLSearchParams(body).toString();\n    }\n  }\n  return JSON.stringify(body);\n}\nfunction createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params?.path) {\n    finalURL = defaultPathSerializer(finalURL, options.params.path);\n  }\n  let search = options.querySerializer(options.params.query ?? {});\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\nfunction mergeHeaders(...allHeaders) {\n  const finalHeaders = new Headers();\n  for (const h of allHeaders) {\n    if (!h || typeof h !== \"object\") {\n      continue;\n    }\n    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        finalHeaders.delete(k);\n      } else if (Array.isArray(v)) {\n        for (const v2 of v) {\n          finalHeaders.append(k, v2);\n        }\n      } else if (v !== void 0) {\n        finalHeaders.set(k, v);\n      }\n    }\n  }\n  return finalHeaders;\n}\nfunction removeTrailingSlash(url) {\n  if (url.endsWith(\"/\")) {\n    return url.substring(0, url.length - 1);\n  }\n  return url;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbmFwaS1mZXRjaC9kaXN0L2Nqcy9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsSUFBSSxJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLDhDQUE4QztBQUM5QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdEQUFnRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUIsSUFBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVDQUF1QztBQUNyRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3RELEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssR0FBRyxvRUFBb0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLLEdBQUcsT0FBTztBQUNqQztBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBLGlCQUFpQixFQUFFLEtBQUssR0FBRyxPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUssR0FBRyxFQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxPQUFPLEVBQUUsTUFBTTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQXNEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUIsRUFBRSxLQUFLLEdBQUcsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLLEdBQUcsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DLEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE9BQU8sRUFBRSxvQkFBb0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkJBQTJCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsZ0JBQWdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxnQkFBZ0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUUscUNBQXFDO0FBQ2hGO0FBQ0E7QUFDQSw2REFBNkQsMEJBQTBCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQixFQUFFLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FyYy1meC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9vcGVuYXBpLWZldGNoL2Rpc3QvY2pzL2luZGV4LmNqcz82YjZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LmpzXG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICBjcmVhdGVGaW5hbFVSTDogKCkgPT4gY3JlYXRlRmluYWxVUkwsXG4gIGNyZWF0ZVBhdGhCYXNlZENsaWVudDogKCkgPT4gY3JlYXRlUGF0aEJhc2VkQ2xpZW50LFxuICBjcmVhdGVRdWVyeVNlcmlhbGl6ZXI6ICgpID0+IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcixcbiAgZGVmYXVsdDogKCkgPT4gY3JlYXRlQ2xpZW50LFxuICBkZWZhdWx0Qm9keVNlcmlhbGl6ZXI6ICgpID0+IGRlZmF1bHRCb2R5U2VyaWFsaXplcixcbiAgZGVmYXVsdFBhdGhTZXJpYWxpemVyOiAoKSA9PiBkZWZhdWx0UGF0aFNlcmlhbGl6ZXIsXG4gIG1lcmdlSGVhZGVyczogKCkgPT4gbWVyZ2VIZWFkZXJzLFxuICByYW5kb21JRDogKCkgPT4gcmFuZG9tSUQsXG4gIHJlbW92ZVRyYWlsaW5nU2xhc2g6ICgpID0+IHJlbW92ZVRyYWlsaW5nU2xhc2gsXG4gIHNlcmlhbGl6ZUFycmF5UGFyYW06ICgpID0+IHNlcmlhbGl6ZUFycmF5UGFyYW0sXG4gIHNlcmlhbGl6ZU9iamVjdFBhcmFtOiAoKSA9PiBzZXJpYWxpemVPYmplY3RQYXJhbSxcbiAgc2VyaWFsaXplUHJpbWl0aXZlUGFyYW06ICgpID0+IHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtLFxuICB3cmFwQXNQYXRoQmFzZWRDbGllbnQ6ICgpID0+IHdyYXBBc1BhdGhCYXNlZENsaWVudFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcbnZhciBQQVRIX1BBUkFNX1JFID0gL1xce1tee31dK1xcfS9nO1xudmFyIHN1cHBvcnRzUmVxdWVzdEluaXRFeHQgPSAoKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBOdW1iZXIucGFyc2VJbnQocHJvY2Vzcz8udmVyc2lvbnM/Lm5vZGU/LnN1YnN0cmluZygwLCAyKSkgPj0gMTggJiYgcHJvY2Vzcy52ZXJzaW9ucy51bmRpY2k7XG59O1xuZnVuY3Rpb24gcmFuZG9tSUQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQoY2xpZW50T3B0aW9ucykge1xuICBsZXQge1xuICAgIGJhc2VVcmwgPSBcIlwiLFxuICAgIFJlcXVlc3Q6IEN1c3RvbVJlcXVlc3QgPSBnbG9iYWxUaGlzLlJlcXVlc3QsXG4gICAgZmV0Y2g6IGJhc2VGZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2gsXG4gICAgcXVlcnlTZXJpYWxpemVyOiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIsXG4gICAgYm9keVNlcmlhbGl6ZXI6IGdsb2JhbEJvZHlTZXJpYWxpemVyLFxuICAgIGhlYWRlcnM6IGJhc2VIZWFkZXJzLFxuICAgIHJlcXVlc3RJbml0RXh0ID0gdm9pZCAwLFxuICAgIC4uLmJhc2VPcHRpb25zXG4gIH0gPSB7IC4uLmNsaWVudE9wdGlvbnMgfTtcbiAgcmVxdWVzdEluaXRFeHQgPSBzdXBwb3J0c1JlcXVlc3RJbml0RXh0KCkgPyByZXF1ZXN0SW5pdEV4dCA6IHZvaWQgMDtcbiAgYmFzZVVybCA9IHJlbW92ZVRyYWlsaW5nU2xhc2goYmFzZVVybCk7XG4gIGNvbnN0IG1pZGRsZXdhcmVzID0gW107XG4gIGFzeW5jIGZ1bmN0aW9uIGNvcmVGZXRjaChzY2hlbWFQYXRoLCBmZXRjaE9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlVXJsOiBsb2NhbEJhc2VVcmwsXG4gICAgICBmZXRjaCA9IGJhc2VGZXRjaCxcbiAgICAgIFJlcXVlc3QgPSBDdXN0b21SZXF1ZXN0LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyA9IHt9LFxuICAgICAgcGFyc2VBcyA9IFwianNvblwiLFxuICAgICAgcXVlcnlTZXJpYWxpemVyOiByZXF1ZXN0UXVlcnlTZXJpYWxpemVyLFxuICAgICAgYm9keVNlcmlhbGl6ZXIgPSBnbG9iYWxCb2R5U2VyaWFsaXplciA/PyBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIsXG4gICAgICBib2R5LFxuICAgICAgLi4uaW5pdFxuICAgIH0gPSBmZXRjaE9wdGlvbnMgfHwge307XG4gICAgbGV0IGZpbmFsQmFzZVVybCA9IGJhc2VVcmw7XG4gICAgaWYgKGxvY2FsQmFzZVVybCkge1xuICAgICAgZmluYWxCYXNlVXJsID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChsb2NhbEJhc2VVcmwpID8/IGJhc2VVcmw7XG4gICAgfVxuICAgIGxldCBxdWVyeVNlcmlhbGl6ZXIgPSB0eXBlb2YgZ2xvYmFsUXVlcnlTZXJpYWxpemVyID09PSBcImZ1bmN0aW9uXCIgPyBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgOiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIoZ2xvYmFsUXVlcnlTZXJpYWxpemVyKTtcbiAgICBpZiAocmVxdWVzdFF1ZXJ5U2VyaWFsaXplcikge1xuICAgICAgcXVlcnlTZXJpYWxpemVyID0gdHlwZW9mIHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIgOiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIoe1xuICAgICAgICAuLi50eXBlb2YgZ2xvYmFsUXVlcnlTZXJpYWxpemVyID09PSBcIm9iamVjdFwiID8gZ2xvYmFsUXVlcnlTZXJpYWxpemVyIDoge30sXG4gICAgICAgIC4uLnJlcXVlc3RRdWVyeVNlcmlhbGl6ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkQm9keSA9IGJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlTZXJpYWxpemVyKFxuICAgICAgYm9keSxcbiAgICAgIC8vIE5vdGU6IHdlIGRlY2xhcmUgbWVyZ2VIZWFkZXJzKCkgYm90aCBoZXJlIGFuZCBiZWxvdyBiZWNhdXNlIGl04oCZcyBhIGJpdCBvZiBhIGNoaWNrZW4tb3ItZWdnIHNpdHVhdGlvbjpcbiAgICAgIC8vIGJvZHlTZXJpYWxpemVyKCkgbmVlZHMgYWxsIGhlYWRlcnMgc28gd2UgYXJlbuKAmXQgZHJvcHBpbmcgb25lcyBzZXQgYnkgdGhlIHVzZXIsIGhvd2V2ZXIsXG4gICAgICAvLyB0aGUgcmVzdWx0IG9mIHRoaXMgQUxTTyBzZXRzIHRoZSBsb3dlc3QtcHJpb3JpdHkgY29udGVudC10eXBlIGhlYWRlci4gU28gd2UgcmUtbWVyZ2UgYmVsb3csXG4gICAgICAvLyBzZXR0aW5nIHRoZSBjb250ZW50LXR5cGUgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHRvIGJlIG92ZXJ3cml0dGVuLlxuICAgICAgLy8gTGFzdGx5LCBiYXNlZCBvbiB0aGUgd2F5IGhlYWRlcnMgd29yaywgaXTigJlzIG5vdCBhIHNpbXBsZcKg4oCccHJlc2VudC1vci1ub3TigJ0gY2hlY2sgYmVjYXVhc2UgbnVsbCBpbnRlbnRpb25hbGx5IHVuLXNldHMgaGVhZGVycy5cbiAgICAgIG1lcmdlSGVhZGVycyhiYXNlSGVhZGVycywgaGVhZGVycywgcGFyYW1zLmhlYWRlcilcbiAgICApO1xuICAgIGNvbnN0IGZpbmFsSGVhZGVycyA9IG1lcmdlSGVhZGVycyhcbiAgICAgIC8vIHdpdGggbm8gYm9keSwgd2Ugc2hvdWxkIG5vdCB0byBzZXQgQ29udGVudC1UeXBlXG4gICAgICBzZXJpYWxpemVkQm9keSA9PT0gdm9pZCAwIHx8IC8vIGlmIHNlcmlhbGl6ZWQgYm9keSBpcyBGb3JtRGF0YTsgYnJvd3NlciB3aWxsIGNvcnJlY3RseSBzZXQgQ29udGVudC1UeXBlICYgYm91bmRhcnkgZXhwcmVzc2lvblxuICAgICAgc2VyaWFsaXplZEJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSA/IHt9IDoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJhc2VIZWFkZXJzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcy5oZWFkZXJcbiAgICApO1xuICAgIGNvbnN0IHJlcXVlc3RJbml0ID0ge1xuICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgIC4uLmluaXQsXG4gICAgICBib2R5OiBzZXJpYWxpemVkQm9keSxcbiAgICAgIGhlYWRlcnM6IGZpbmFsSGVhZGVyc1xuICAgIH07XG4gICAgbGV0IGlkO1xuICAgIGxldCBvcHRpb25zO1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEN1c3RvbVJlcXVlc3QoXG4gICAgICBjcmVhdGVGaW5hbFVSTChzY2hlbWFQYXRoLCB7IGJhc2VVcmw6IGZpbmFsQmFzZVVybCwgcGFyYW1zLCBxdWVyeVNlcmlhbGl6ZXIgfSksXG4gICAgICByZXF1ZXN0SW5pdFxuICAgICk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluaXQpIHtcbiAgICAgIGlmICghKGtleSBpbiByZXF1ZXN0KSkge1xuICAgICAgICByZXF1ZXN0W2tleV0gPSBpbml0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgIGlkID0gcmFuZG9tSUQoKTtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgYmFzZVVybDogZmluYWxCYXNlVXJsLFxuICAgICAgICBmZXRjaCxcbiAgICAgICAgcGFyc2VBcyxcbiAgICAgICAgcXVlcnlTZXJpYWxpemVyLFxuICAgICAgICBib2R5U2VyaWFsaXplclxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZXMpIHtcbiAgICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25SZXF1ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtLm9uUmVxdWVzdCh7XG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBDdXN0b21SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uUmVxdWVzdDogbXVzdCByZXR1cm4gbmV3IFJlcXVlc3QoKSBvciBSZXNwb25zZSgpIHdoZW4gbW9kaWZ5aW5nIHRoZSByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QsIHJlcXVlc3RJbml0RXh0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBsZXQgZXJyb3JBZnRlck1pZGRsZXdhcmUgPSBlcnJvcjI7XG4gICAgICAgIGlmIChtaWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gbWlkZGxld2FyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtaWRkbGV3YXJlc1tpXTtcbiAgICAgICAgICAgIGlmIChtICYmIHR5cGVvZiBtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtLm9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yQWZ0ZXJNaWRkbGV3YXJlLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yQWZ0ZXJNaWRkbGV3YXJlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvckFmdGVyTWlkZGxld2FyZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbkVycm9yOiBtdXN0IHJldHVybiBuZXcgUmVzcG9uc2UoKSBvciBpbnN0YW5jZSBvZiBFcnJvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JBZnRlck1pZGRsZXdhcmUpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvckFmdGVyTWlkZGxld2FyZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gbWlkZGxld2FyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBtID0gbWlkZGxld2FyZXNbaV07XG4gICAgICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25SZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtLm9uUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uUmVzcG9uc2U6IG11c3QgcmV0dXJuIG5ldyBSZXNwb25zZSgpIHdoZW4gbW9kaWZ5aW5nIHRoZSByZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlcXVlc3QubWV0aG9kID09PSBcIkhFQURcIiB8fCByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpID09PSBcIjBcIikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8geyBkYXRhOiB2b2lkIDAsIHJlc3BvbnNlIH0gOiB7IGVycm9yOiB2b2lkIDAsIHJlc3BvbnNlIH07XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgaWYgKHBhcnNlQXMgPT09IFwic3RyZWFtXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzcG9uc2UuYm9keSwgcmVzcG9uc2UgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IGF3YWl0IHJlc3BvbnNlW3BhcnNlQXNdKCksIHJlc3BvbnNlIH07XG4gICAgfVxuICAgIGxldCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB0cnkge1xuICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGVycm9yKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3IsIHJlc3BvbnNlIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXF1ZXN0KG1ldGhvZCwgdXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBHRVQgZW5kcG9pbnQgKi9cbiAgICBHRVQodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiR0VUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBVVCBlbmRwb2ludCAqL1xuICAgIFBVVCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQVVRcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUE9TVCBlbmRwb2ludCAqL1xuICAgIFBPU1QodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUE9TVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBERUxFVEUgZW5kcG9pbnQgKi9cbiAgICBERUxFVEUodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiREVMRVRFXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIE9QVElPTlMgZW5kcG9pbnQgKi9cbiAgICBPUFRJT05TKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIk9QVElPTlNcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgSEVBRCBlbmRwb2ludCAqL1xuICAgIEhFQUQodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiSEVBRFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQQVRDSCBlbmRwb2ludCAqL1xuICAgIFBBVENIKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBBVENIXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFRSQUNFIGVuZHBvaW50ICovXG4gICAgVFJBQ0UodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiVFJBQ0VcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBSZWdpc3RlciBtaWRkbGV3YXJlICovXG4gICAgdXNlKC4uLm1pZGRsZXdhcmUpIHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtaWRkbGV3YXJlKSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbSAhPT0gXCJvYmplY3RcIiB8fCAhKFwib25SZXF1ZXN0XCIgaW4gbSB8fCBcIm9uUmVzcG9uc2VcIiBpbiBtIHx8IFwib25FcnJvclwiIGluIG0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlkZGxld2FyZSBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG9uZSBvZiBgb25SZXF1ZXN0KClgLCBgb25SZXNwb25zZSgpIG9yIGBvbkVycm9yKClgXCIpO1xuICAgICAgICB9XG4gICAgICAgIG1pZGRsZXdhcmVzLnB1c2gobSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogVW5yZWdpc3RlciBtaWRkbGV3YXJlICovXG4gICAgZWplY3QoLi4ubWlkZGxld2FyZSkge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG1pZGRsZXdhcmUpIHtcbiAgICAgICAgY29uc3QgaSA9IG1pZGRsZXdhcmVzLmluZGV4T2YobSk7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgIG1pZGRsZXdhcmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBQYXRoQ2FsbEZvcndhcmRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCB1cmwpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfVxuICBHRVQgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5HRVQodGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBQVVQgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QVVQodGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBQT1NUID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuUE9TVCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIERFTEVURSA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LkRFTEVURSh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIE9QVElPTlMgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5PUFRJT05TKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgSEVBRCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LkhFQUQodGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBQQVRDSCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LlBBVENIKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgVFJBQ0UgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5UUkFDRSh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG59O1xudmFyIFBhdGhDbGllbnRQcm94eUhhbmRsZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcbiAgfVxuICAvLyBBc3N1bWUgdGhlIHByb3BlcnR5IGlzIGFuIFVSTC5cbiAgZ2V0KGNvcmVDbGllbnQsIHVybCkge1xuICAgIGNvbnN0IGZvcndhcmRlciA9IG5ldyBQYXRoQ2FsbEZvcndhcmRlcihjb3JlQ2xpZW50LCB1cmwpO1xuICAgIHRoaXMuY2xpZW50W3VybF0gPSBmb3J3YXJkZXI7XG4gICAgcmV0dXJuIGZvcndhcmRlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHdyYXBBc1BhdGhCYXNlZENsaWVudChjb3JlQ2xpZW50KSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBuZXcgUGF0aENsaWVudFByb3h5SGFuZGxlcigpO1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShjb3JlQ2xpZW50LCBoYW5kbGVyKTtcbiAgZnVuY3Rpb24gQ2xpZW50KCkge1xuICB9XG4gIENsaWVudC5wcm90b3R5cGUgPSBwcm94eTtcbiAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICBoYW5kbGVyLmNsaWVudCA9IGNsaWVudDtcbiAgcmV0dXJuIGNsaWVudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhCYXNlZENsaWVudChjbGllbnRPcHRpb25zKSB7XG4gIHJldHVybiB3cmFwQXNQYXRoQmFzZWRDbGllbnQoY3JlYXRlQ2xpZW50KGNsaWVudE9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiRGVlcGx5LW5lc3RlZCBhcnJheXMvb2JqZWN0cyBhcmVuXFx1MjAxOXQgc3VwcG9ydGVkLiBQcm92aWRlIHlvdXIgb3duIGBxdWVyeVNlcmlhbGl6ZXIoKWAgdG8gaGFuZGxlIHRoZXNlLlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYCR7bmFtZX09JHtvcHRpb25zPy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWUgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3RQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBjb25zdCBqb2luZXIgPSB7XG4gICAgc2ltcGxlOiBcIixcIixcbiAgICBsYWJlbDogXCIuXCIsXG4gICAgbWF0cml4OiBcIjtcIlxuICB9W29wdGlvbnMuc3R5bGVdIHx8IFwiJlwiO1xuICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gXCJkZWVwT2JqZWN0XCIgJiYgb3B0aW9ucy5leHBsb2RlID09PSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgdmFsdWVzLnB1c2goaywgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWVba10gOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWVba10pKTtcbiAgICB9XG4gICAgY29uc3QgZmluYWwyID0gdmFsdWVzLmpvaW4oXCIsXCIpO1xuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcImZvcm1cIjoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbDJ9YDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsYWJlbFwiOiB7XG4gICAgICAgIHJldHVybiBgLiR7ZmluYWwyfWA7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWF0cml4XCI6IHtcbiAgICAgICAgcmV0dXJuIGA7JHtuYW1lfT0ke2ZpbmFsMn1gO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gZmluYWwyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICBjb25zdCBmaW5hbE5hbWUgPSBvcHRpb25zLnN0eWxlID09PSBcImRlZXBPYmplY3RcIiA/IGAke25hbWV9WyR7a31dYCA6IGs7XG4gICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oZmluYWxOYW1lLCB2YWx1ZVtrXSwgb3B0aW9ucykpO1xuICB9XG4gIGNvbnN0IGZpbmFsID0gdmFsdWVzLmpvaW4oam9pbmVyKTtcbiAgcmV0dXJuIG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcIm1hdHJpeFwiID8gYCR7am9pbmVyfSR7ZmluYWx9YCA6IGZpbmFsO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZXhwbG9kZSA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBqb2luZXIyID0geyBmb3JtOiBcIixcIiwgc3BhY2VEZWxpbWl0ZWQ6IFwiJTIwXCIsIHBpcGVEZWxpbWl0ZWQ6IFwifFwiIH1bb3B0aW9ucy5zdHlsZV0gfHwgXCIsXCI7XG4gICAgY29uc3QgZmluYWwgPSAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWUgOiB2YWx1ZS5tYXAoKHYpID0+IGVuY29kZVVSSUNvbXBvbmVudCh2KSkpLmpvaW4oam9pbmVyMik7XG4gICAgc3dpdGNoIChvcHRpb25zLnN0eWxlKSB7XG4gICAgICBjYXNlIFwic2ltcGxlXCI6IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxhYmVsXCI6IHtcbiAgICAgICAgcmV0dXJuIGAuJHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hdHJpeFwiOiB7XG4gICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgLy8gY2FzZSBcInNwYWNlRGVsaW1pdGVkXCI6XG4gICAgICAvLyBjYXNlIFwicGlwZURlbGltaXRlZFwiOlxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBqb2luZXIgPSB7IHNpbXBsZTogXCIsXCIsIGxhYmVsOiBcIi5cIiwgbWF0cml4OiBcIjtcIiB9W29wdGlvbnMuc3R5bGVdIHx8IFwiJlwiO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUgPT09IFwic2ltcGxlXCIgfHwgb3B0aW9ucy5zdHlsZSA9PT0gXCJsYWJlbFwiKSB7XG4gICAgICB2YWx1ZXMucHVzaChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2IDogZW5jb2RlVVJJQ29tcG9uZW50KHYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdiwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9ucy5zdHlsZSA9PT0gXCJsYWJlbFwiIHx8IG9wdGlvbnMuc3R5bGUgPT09IFwibWF0cml4XCIgPyBgJHtqb2luZXJ9JHt2YWx1ZXMuam9pbihqb2luZXIpfWAgOiB2YWx1ZXMuam9pbihqb2luZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVlcnlTZXJpYWxpemVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXJ5U2VyaWFsaXplcihxdWVyeVBhcmFtcykge1xuICAgIGNvbnN0IHNlYXJjaCA9IFtdO1xuICAgIGlmIChxdWVyeVBhcmFtcyAmJiB0eXBlb2YgcXVlcnlQYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5UGFyYW1zW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IFwiZm9ybVwiLFxuICAgICAgICAgICAgICBleHBsb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zPy5hcnJheSxcbiAgICAgICAgICAgICAgYWxsb3dSZXNlcnZlZDogb3B0aW9ucz8uYWxsb3dSZXNlcnZlZCB8fCBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImRlZXBPYmplY3RcIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8ub2JqZWN0LFxuICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkOiBvcHRpb25zPy5hbGxvd1Jlc2VydmVkIHx8IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VhcmNoLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlYXJjaC5qb2luKFwiJlwiKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQYXRoU2VyaWFsaXplcihwYXRobmFtZSwgcGF0aFBhcmFtcykge1xuICBsZXQgbmV4dFVSTCA9IHBhdGhuYW1lO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIHBhdGhuYW1lLm1hdGNoKFBBVEhfUEFSQU1fUkUpID8/IFtdKSB7XG4gICAgbGV0IG5hbWUgPSBtYXRjaC5zdWJzdHJpbmcoMSwgbWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgbGV0IGV4cGxvZGUgPSBmYWxzZTtcbiAgICBsZXQgc3R5bGUgPSBcInNpbXBsZVwiO1xuICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgZXhwbG9kZSA9IHRydWU7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIHN0eWxlID0gXCJsYWJlbFwiO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKFwiO1wiKSkge1xuICAgICAgc3R5bGUgPSBcIm1hdHJpeFwiO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoIXBhdGhQYXJhbXMgfHwgcGF0aFBhcmFtc1tuYW1lXSA9PT0gdm9pZCAwIHx8IHBhdGhQYXJhbXNbbmFtZV0gPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHBhdGhQYXJhbXNbbmFtZV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCB7IHN0eWxlLCBleHBsb2RlIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVPYmplY3RQYXJhbShuYW1lLCB2YWx1ZSwgeyBzdHlsZSwgZXhwbG9kZSB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlID09PSBcIm1hdHJpeFwiKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBgOyR7c2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUpfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5leHRVUkwgPSBuZXh0VVJMLnJlcGxhY2UobWF0Y2gsIHN0eWxlID09PSBcImxhYmVsXCIgPyBgLiR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIG5leHRVUkw7XG59XG5mdW5jdGlvbiBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIoYm9keSwgaGVhZGVycykge1xuICBpZiAoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgaWYgKGhlYWRlcnMpIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBoZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSA/PyBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSA6IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPz8gaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpIHtcbiAgICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKGJvZHkpLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShib2R5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbmFsVVJMKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGxldCBmaW5hbFVSTCA9IGAke29wdGlvbnMuYmFzZVVybH0ke3BhdGhuYW1lfWA7XG4gIGlmIChvcHRpb25zLnBhcmFtcz8ucGF0aCkge1xuICAgIGZpbmFsVVJMID0gZGVmYXVsdFBhdGhTZXJpYWxpemVyKGZpbmFsVVJMLCBvcHRpb25zLnBhcmFtcy5wYXRoKTtcbiAgfVxuICBsZXQgc2VhcmNoID0gb3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXIob3B0aW9ucy5wYXJhbXMucXVlcnkgPz8ge30pO1xuICBpZiAoc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgfVxuICBpZiAoc2VhcmNoKSB7XG4gICAgZmluYWxVUkwgKz0gYD8ke3NlYXJjaH1gO1xuICB9XG4gIHJldHVybiBmaW5hbFVSTDtcbn1cbmZ1bmN0aW9uIG1lcmdlSGVhZGVycyguLi5hbGxIZWFkZXJzKSB7XG4gIGNvbnN0IGZpbmFsSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAoY29uc3QgaCBvZiBhbGxIZWFkZXJzKSB7XG4gICAgaWYgKCFoIHx8IHR5cGVvZiBoICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXRlcmF0b3IgPSBoIGluc3RhbmNlb2YgSGVhZGVycyA/IGguZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoaCk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgaXRlcmF0b3IpIHtcbiAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5kZWxldGUoayk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgZm9yIChjb25zdCB2MiBvZiB2KSB7XG4gICAgICAgICAgZmluYWxIZWFkZXJzLmFwcGVuZChrLCB2Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5zZXQoaywgdik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbEhlYWRlcnM7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NsYXNoKHVybCkge1xuICBpZiAodXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/openapi-fetch/dist/cjs/index.cjs\n");

/***/ })

};
;