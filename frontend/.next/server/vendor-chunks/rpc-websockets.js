"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rpc-websockets";
exports.ids = ["vendor-chunks/rpc-websockets"];
exports.modules = {

/***/ "(ssr)/./node_modules/rpc-websockets/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CommonClient: () => (/* binding */ CommonClient),\n/* harmony export */   DefaultDataPack: () => (/* binding */ DefaultDataPack),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   WebSocket: () => (/* binding */ WebSocket),\n/* harmony export */   createError: () => (/* binding */ createError)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/v1.js\");\n\n\n\n\n\n// src/lib/client/websocket.ts\nfunction WebSocket(address, options) {\n  return new ws__WEBPACK_IMPORTED_MODULE_0__[\"default\"](address, options);\n}\n\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n  encode(value) {\n    return JSON.stringify(value);\n  }\n  decode(value) {\n    return JSON.parse(value);\n  }\n};\n\n// src/lib/client.ts\nvar CommonClient = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n  address;\n  rpc_id;\n  queue;\n  options;\n  autoconnect;\n  ready;\n  reconnect;\n  reconnect_timer_id;\n  reconnect_interval;\n  max_reconnects;\n  rest_options;\n  current_reconnects;\n  generate_request_id;\n  socket;\n  webSocketFactory;\n  dataPack;\n  /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */\n  constructor(webSocketFactory, address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1e3,\n    max_reconnects = 5,\n    ...rest_options\n  } = {}, generate_request_id, dataPack) {\n    super();\n    this.webSocketFactory = webSocketFactory;\n    this.queue = {};\n    this.rpc_id = 0;\n    this.address = address;\n    this.autoconnect = autoconnect;\n    this.ready = false;\n    this.reconnect = reconnect;\n    this.reconnect_timer_id = void 0;\n    this.reconnect_interval = reconnect_interval;\n    this.max_reconnects = max_reconnects;\n    this.rest_options = rest_options;\n    this.current_reconnects = 0;\n    this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === \"number\" ? ++this.rpc_id : Number(this.rpc_id) + 1);\n    if (!dataPack) this.dataPack = new DefaultDataPack();\n    else this.dataPack = dataPack;\n    if (this.autoconnect)\n      this._connect(this.address, {\n        autoconnect: this.autoconnect,\n        reconnect: this.reconnect,\n        reconnect_interval: this.reconnect_interval,\n        max_reconnects: this.max_reconnects,\n        ...this.rest_options\n      });\n  }\n  /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */\n  connect() {\n    if (this.socket) return;\n    this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */\n  call(method, params, timeout, ws_opts) {\n    if (!ws_opts && \"object\" === typeof timeout) {\n      ws_opts = timeout;\n      timeout = null;\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const rpc_id = this.generate_request_id(method, params);\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params: params || void 0,\n        id: rpc_id\n      };\n      this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {\n        if (error) return reject(error);\n        this.queue[rpc_id] = { promise: [resolve, reject] };\n        if (timeout) {\n          this.queue[rpc_id].timeout = setTimeout(() => {\n            delete this.queue[rpc_id];\n            reject(new Error(\"reply timeout\"));\n          }, timeout);\n        }\n      });\n    });\n  }\n  /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */\n  async login(params) {\n    const resp = await this.call(\"rpc.login\", params);\n    if (!resp) throw new Error(\"authentication failed\");\n    return resp;\n  }\n  /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */\n  async listMethods() {\n    return await this.call(\"__listMethods\");\n  }\n  /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */\n  notify(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params\n      };\n      this.socket.send(this.dataPack.encode(message), (error) => {\n        if (error) return reject(error);\n        resolve();\n      });\n    });\n  }\n  /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async subscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.on\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\")\n      throw new Error(\n        \"Failed subscribing to an event '\" + event + \"' with: \" + result[event]\n      );\n    return result;\n  }\n  /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async unsubscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.off\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\")\n      throw new Error(\"Failed unsubscribing from an event with: \" + result);\n    return result;\n  }\n  /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */\n  close(code, data) {\n    if (this.socket) this.socket.close(code || 1e3, data);\n  }\n  /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */\n  setAutoReconnect(reconnect) {\n    this.reconnect = reconnect;\n  }\n  /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */\n  setReconnectInterval(interval) {\n    this.reconnect_interval = interval;\n  }\n  /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */\n  setMaxReconnects(max_reconnects) {\n    this.max_reconnects = max_reconnects;\n  }\n  /**\n  * Get the current number of reconnection attempts made.\n  * @method\n  * @return {Number} current reconnection attempts\n  */\n  getCurrentReconnects() {\n    return this.current_reconnects;\n  }\n  /**\n  * Get the maximum number of reconnection attempts.\n  * @method\n  * @return {Number} maximum reconnection attempts\n  */\n  getMaxReconnects() {\n    return this.max_reconnects;\n  }\n  /**\n  * Check if the client is currently attempting to reconnect.\n  * @method\n  * @return {Boolean} true if reconnection is in progress\n  */\n  isReconnecting() {\n    return this.reconnect_timer_id !== void 0;\n  }\n  /**\n  * Check if the client will attempt to reconnect on the next close event.\n  * @method\n  * @return {Boolean} true if reconnection will be attempted\n  */\n  willReconnect() {\n    return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);\n  }\n  /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */\n  _connect(address, options) {\n    clearTimeout(this.reconnect_timer_id);\n    this.socket = this.webSocketFactory(address, options);\n    this.socket.addEventListener(\"open\", () => {\n      this.ready = true;\n      this.emit(\"open\");\n      this.current_reconnects = 0;\n    });\n    this.socket.addEventListener(\"message\", ({ data: message }) => {\n      if (message instanceof ArrayBuffer)\n        message = Buffer.from(message).toString();\n      try {\n        message = this.dataPack.decode(message);\n      } catch (error) {\n        return;\n      }\n      if (message.notification && this.listeners(message.notification).length) {\n        if (!Object.keys(message.params).length)\n          return this.emit(message.notification);\n        const args = [message.notification];\n        if (message.params.constructor === Object) args.push(message.params);\n        else\n          for (let i = 0; i < message.params.length; i++)\n            args.push(message.params[i]);\n        return Promise.resolve().then(() => {\n          this.emit.apply(this, args);\n        });\n      }\n      if (!this.queue[message.id]) {\n        if (message.method) {\n          return Promise.resolve().then(() => {\n            this.emit(message.method, message?.params);\n          });\n        }\n        return;\n      }\n      if (\"error\" in message === \"result\" in message)\n        this.queue[message.id].promise[1](\n          new Error(\n            'Server response malformed. Response must include either \"result\" or \"error\", but not both.'\n          )\n        );\n      if (this.queue[message.id].timeout)\n        clearTimeout(this.queue[message.id].timeout);\n      if (message.error) this.queue[message.id].promise[1](message.error);\n      else this.queue[message.id].promise[0](message.result);\n      delete this.queue[message.id];\n    });\n    this.socket.addEventListener(\"error\", (error) => this.emit(\"error\", error));\n    this.socket.addEventListener(\"close\", ({ code, reason }) => {\n      if (this.ready)\n        setTimeout(() => this.emit(\"close\", code, reason), 0);\n      this.ready = false;\n      this.socket = void 0;\n      if (code === 1e3) return;\n      this.current_reconnects++;\n      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))\n        this.reconnect_timer_id = setTimeout(\n          () => this._connect(address, options),\n          this.reconnect_interval\n        );\n      else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {\n        setTimeout(() => this.emit(\"max_reconnects_reached\", code, reason), 1);\n      }\n    });\n  }\n};\nvar Server = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n  namespaces;\n  dataPack;\n  wss;\n  /**\n  * Instantiate a Server class.\n  * @constructor\n  * @param {Object} options - ws constructor's parameters with rpc\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {Server} - returns a new Server instance\n  */\n  constructor(options, dataPack) {\n    super();\n    this.namespaces = {};\n    if (!dataPack) this.dataPack = new DefaultDataPack();\n    else this.dataPack = dataPack;\n    this.wss = new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocketServer(options);\n    this.wss.on(\"listening\", () => this.emit(\"listening\"));\n    this.wss.on(\"connection\", (socket, request) => {\n      const u = node_url__WEBPACK_IMPORTED_MODULE_2__.parse(request.url, true);\n      const ns = u.pathname;\n      if (u.query.socket_id) socket._id = u.query.socket_id;\n      else socket._id = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n      socket[\"_authenticated\"] = false;\n      socket.on(\"error\", (error) => this.emit(\"socket-error\", socket, error));\n      socket.on(\"close\", () => {\n        this.namespaces[ns].clients.delete(socket._id);\n        for (const event of Object.keys(this.namespaces[ns].events)) {\n          const index = this.namespaces[ns].events[event].sockets.indexOf(\n            socket._id\n          );\n          if (index >= 0)\n            this.namespaces[ns].events[event].sockets.splice(index, 1);\n        }\n        this.emit(\"disconnection\", socket);\n      });\n      if (!this.namespaces[ns]) this._generateNamespace(ns);\n      this.namespaces[ns].clients.set(socket._id, socket);\n      this.emit(\"connection\", socket, request);\n      return this._handleRPC(socket, ns);\n    });\n    this.wss.on(\"error\", (error) => this.emit(\"error\", error));\n  }\n  /**\n  * Registers an RPC method.\n  * @method\n  * @param {String} name - method name\n  * @param {Function} fn - a callee function\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IMethod object\n  */\n  register(name, fn, ns = \"/\") {\n    if (!this.namespaces[ns]) this._generateNamespace(ns);\n    this.namespaces[ns].rpc_methods[name] = {\n      fn,\n      protected: false\n    };\n    return {\n      protected: () => this._makeProtectedMethod(name, ns),\n      public: () => this._makePublicMethod(name, ns)\n    };\n  }\n  /**\n  * Sets an auth method.\n  * @method\n  * @param {Function} fn - an arbitrary auth method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */\n  setAuth(fn, ns = \"/\") {\n    this.register(\"rpc.login\", fn, ns);\n  }\n  /**\n  * Marks an RPC method as protected.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makeProtectedMethod(name, ns = \"/\") {\n    this.namespaces[ns].rpc_methods[name].protected = true;\n  }\n  /**\n  * Marks an RPC method as public.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makePublicMethod(name, ns = \"/\") {\n    this.namespaces[ns].rpc_methods[name].protected = false;\n  }\n  /**\n  * Marks an event as protected.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makeProtectedEvent(name, ns = \"/\") {\n    this.namespaces[ns].events[name].protected = true;\n  }\n  /**\n  * Marks an event as public.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makePublicEvent(name, ns = \"/\") {\n    this.namespaces[ns].events[name].protected = false;\n  }\n  /**\n  * Removes a namespace and closes all connections\n  * @method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */\n  closeNamespace(ns) {\n    const namespace = this.namespaces[ns];\n    if (namespace) {\n      delete namespace.rpc_methods;\n      delete namespace.events;\n      for (const socket of namespace.clients.values()) socket.close();\n      delete this.namespaces[ns];\n    }\n  }\n  /**\n  * Creates a new event that can be emitted to clients.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IEvent object\n  */\n  event(name, ns = \"/\") {\n    if (!this.namespaces[ns]) this._generateNamespace(ns);\n    else {\n      const index = this.namespaces[ns].events[name];\n      if (index !== void 0)\n        throw new Error(`Already registered event ${ns}${name}`);\n    }\n    this.namespaces[ns].events[name] = {\n      sockets: [],\n      protected: false\n    };\n    this.on(name, (...params) => {\n      if (params.length === 1 && params[0] instanceof Object)\n        params = params[0];\n      for (const socket_id of this.namespaces[ns].events[name].sockets) {\n        const socket = this.namespaces[ns].clients.get(socket_id);\n        if (!socket) continue;\n        socket.send(\n          this.dataPack.encode({\n            notification: name,\n            params\n          })\n        );\n      }\n    });\n    return {\n      protected: () => this._makeProtectedEvent(name, ns),\n      public: () => this._makePublicEvent(name, ns)\n    };\n  }\n  /**\n  * Returns a requested namespace object\n  * @method\n  * @param {String} name - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - namespace object\n  */\n  of(name) {\n    if (!this.namespaces[name]) this._generateNamespace(name);\n    const self = this;\n    return {\n      // self.register convenience method\n      register(fn_name, fn) {\n        if (arguments.length !== 2)\n          throw new Error(\"must provide exactly two arguments\");\n        if (typeof fn_name !== \"string\")\n          throw new Error(\"name must be a string\");\n        if (typeof fn !== \"function\")\n          throw new Error(\"handler must be a function\");\n        return self.register(fn_name, fn, name);\n      },\n      // self.event convenience method\n      event(ev_name) {\n        if (arguments.length !== 1)\n          throw new Error(\"must provide exactly one argument\");\n        if (typeof ev_name !== \"string\")\n          throw new Error(\"name must be a string\");\n        return self.event(ev_name, name);\n      },\n      // self.eventList convenience method\n      get eventList() {\n        return Object.keys(self.namespaces[name].events);\n      },\n      /**\n      * Emits a specified event to this namespace.\n      * @inner\n      * @method\n      * @param {String} event - event name\n      * @param {Array} params - event parameters\n      * @return {Undefined}\n      */\n      emit(event, ...params) {\n        const nsEvent = self.namespaces[name].events[event];\n        if (nsEvent)\n          for (const socket_id of nsEvent.sockets) {\n            const socket = self.namespaces[name].clients.get(socket_id);\n            if (!socket) continue;\n            socket.send(\n              self.dataPack.encode({\n                notification: event,\n                params\n              })\n            );\n          }\n      },\n      /**\n      * Returns a name of this namespace.\n      * @inner\n      * @method\n      * @kind constant\n      * @return {String}\n      */\n      get name() {\n        return name;\n      },\n      /**\n      * Returns a hash of websocket objects connected to this namespace.\n      * @inner\n      * @method\n      * @return {Object}\n      */\n      connected() {\n        const socket_ids = [...self.namespaces[name].clients.keys()];\n        return socket_ids.reduce(\n          (acc, curr) => ({\n            ...acc,\n            [curr]: self.namespaces[name].clients.get(curr)\n          }),\n          {}\n        );\n      },\n      /**\n      * Returns a list of client unique identifiers connected to this namespace.\n      * @inner\n      * @method\n      * @return {Array}\n      */\n      clients() {\n        return self.namespaces[name];\n      }\n    };\n  }\n  /**\n  * Lists all created events in a given namespace. Defaults to \"/\".\n  * @method\n  * @param {String} ns - namespaces identifier\n  * @readonly\n  * @return {Array} - returns a list of created events\n  */\n  eventList(ns = \"/\") {\n    if (!this.namespaces[ns]) return [];\n    return Object.keys(this.namespaces[ns].events);\n  }\n  /**\n  * Creates a JSON-RPC 2.0 compliant error\n  * @method\n  * @param {Number} code - indicates the error type that occurred\n  * @param {String} message - provides a short description of the error\n  * @param {String|Object} data - details containing additional information about the error\n  * @return {Object}\n  */\n  createError(code, message, data) {\n    return {\n      code,\n      message,\n      data: data || null\n    };\n  }\n  /**\n  * Closes the server and terminates all clients.\n  * @method\n  * @return {Promise}\n  */\n  close() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.wss.close();\n        this.emit(\"close\");\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  /**\n  * Handles all WebSocket JSON RPC 2.0 requests.\n  * @private\n  * @param {Object} socket - ws socket instance\n  * @param {String} ns - namespaces identifier\n  * @return {Undefined}\n  */\n  _handleRPC(socket, ns = \"/\") {\n    socket.on(\"message\", async (data) => {\n      const msg_options = {};\n      if (data instanceof ArrayBuffer) {\n        msg_options.binary = true;\n        data = Buffer.from(data).toString();\n      }\n      if (socket.readyState !== 1) return;\n      let parsedData;\n      try {\n        parsedData = this.dataPack.decode(data);\n      } catch (error) {\n        return socket.send(\n          this.dataPack.encode({\n            jsonrpc: \"2.0\",\n            error: createError(-32700, error.toString()),\n            id: null\n          }),\n          msg_options\n        );\n      }\n      if (Array.isArray(parsedData)) {\n        if (!parsedData.length)\n          return socket.send(\n            this.dataPack.encode({\n              jsonrpc: \"2.0\",\n              error: createError(-32600, \"Invalid array\"),\n              id: null\n            }),\n            msg_options\n          );\n        const responses = [];\n        for (const message of parsedData) {\n          const response2 = await this._runMethod(message, socket._id, ns);\n          if (!response2) continue;\n          responses.push(response2);\n        }\n        if (!responses.length) return;\n        return socket.send(this.dataPack.encode(responses), msg_options);\n      }\n      const response = await this._runMethod(parsedData, socket._id, ns);\n      if (!response) return;\n      return socket.send(this.dataPack.encode(response), msg_options);\n    });\n  }\n  /**\n  * Runs a defined RPC method.\n  * @private\n  * @param {Object} message - a message received\n  * @param {Object} socket_id - user's socket id\n  * @param {String} ns - namespaces identifier\n  * @return {Object|undefined}\n  */\n  async _runMethod(message, socket_id, ns = \"/\") {\n    if (typeof message !== \"object\" || message === null)\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600),\n        id: null\n      };\n    if (message.jsonrpc !== \"2.0\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600, \"Invalid JSON RPC version\"),\n        id: message.id || null\n      };\n    if (!message.method)\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32602, \"Method not specified\"),\n        id: message.id || null\n      };\n    if (typeof message.method !== \"string\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600, \"Invalid method name\"),\n        id: message.id || null\n      };\n    if (message.params && typeof message.params === \"string\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600),\n        id: message.id || null\n      };\n    if (message.method === \"rpc.on\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32e3),\n          id: message.id || null\n        };\n      const results = {};\n      const event_names = Object.keys(this.namespaces[ns].events);\n      for (const name of message.params) {\n        const index = event_names.indexOf(name);\n        const namespace = this.namespaces[ns];\n        if (index === -1) {\n          results[name] = \"provided event invalid\";\n          continue;\n        }\n        if (namespace.events[event_names[index]].protected === true && namespace.clients.get(socket_id)[\"_authenticated\"] === false) {\n          return {\n            jsonrpc: \"2.0\",\n            error: createError(-32606),\n            id: message.id || null\n          };\n        }\n        const socket_index = namespace.events[event_names[index]].sockets.indexOf(socket_id);\n        if (socket_index >= 0) {\n          results[name] = \"socket has already been subscribed to event\";\n          continue;\n        }\n        namespace.events[event_names[index]].sockets.push(socket_id);\n        results[name] = \"ok\";\n      }\n      return {\n        jsonrpc: \"2.0\",\n        result: results,\n        id: message.id || null\n      };\n    } else if (message.method === \"rpc.off\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32e3),\n          id: message.id || null\n        };\n      const results = {};\n      for (const name of message.params) {\n        if (!this.namespaces[ns].events[name]) {\n          results[name] = \"provided event invalid\";\n          continue;\n        }\n        const index = this.namespaces[ns].events[name].sockets.indexOf(socket_id);\n        if (index === -1) {\n          results[name] = \"not subscribed\";\n          continue;\n        }\n        this.namespaces[ns].events[name].sockets.splice(index, 1);\n        results[name] = \"ok\";\n      }\n      return {\n        jsonrpc: \"2.0\",\n        result: results,\n        id: message.id || null\n      };\n    } else if (message.method === \"rpc.login\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32604),\n          id: message.id || null\n        };\n    }\n    if (!this.namespaces[ns].rpc_methods[message.method]) {\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32601),\n        id: message.id || null\n      };\n    }\n    let response = null;\n    if (this.namespaces[ns].rpc_methods[message.method].protected === true && this.namespaces[ns].clients.get(socket_id)[\"_authenticated\"] === false) {\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32605),\n        id: message.id || null\n      };\n    }\n    try {\n      response = await this.namespaces[ns].rpc_methods[message.method].fn(\n        message.params,\n        socket_id\n      );\n    } catch (error) {\n      if (!message.id) return;\n      if (error instanceof Error)\n        return {\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32e3,\n            message: error.name,\n            data: error.message\n          },\n          id: message.id\n        };\n      return {\n        jsonrpc: \"2.0\",\n        error,\n        id: message.id\n      };\n    }\n    if (!message.id) return;\n    if (message.method === \"rpc.login\" && response === true) {\n      const s = this.namespaces[ns].clients.get(socket_id);\n      s[\"_authenticated\"] = true;\n      this.namespaces[ns].clients.set(socket_id, s);\n    }\n    return {\n      jsonrpc: \"2.0\",\n      result: response,\n      id: message.id\n    };\n  }\n  /**\n  * Generate a new namespace store.\n  * Also preregister some special namespace methods.\n  * @private\n  * @param {String} name - namespaces identifier\n  * @return {undefined}\n  */\n  _generateNamespace(name) {\n    this.namespaces[name] = {\n      rpc_methods: {\n        __listMethods: {\n          fn: () => Object.keys(this.namespaces[name].rpc_methods),\n          protected: false\n        }\n      },\n      clients: /* @__PURE__ */ new Map(),\n      events: {}\n    };\n  }\n};\nvar RPC_ERRORS = /* @__PURE__ */ new Map([\n  [-32e3, \"Event not provided\"],\n  [-32600, \"Invalid Request\"],\n  [-32601, \"Method not found\"],\n  [-32602, \"Invalid params\"],\n  [-32603, \"Internal error\"],\n  [-32604, \"Params not found\"],\n  [-32605, \"Method forbidden\"],\n  [-32606, \"Event forbidden\"],\n  [-32700, \"Parse error\"]\n]);\nfunction createError(code, details) {\n  const error = {\n    code,\n    message: RPC_ERRORS.get(code) || \"Internal Server Error\"\n  };\n  if (details) error[\"data\"] = details;\n  return error;\n}\n\n// src/index.ts\nvar Client = class extends CommonClient {\n  constructor(address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1e3,\n    max_reconnects = 5,\n    ...rest_options\n  } = {}, generate_request_id) {\n    super(\n      WebSocket,\n      address,\n      {\n        autoconnect,\n        reconnect,\n        reconnect_interval,\n        max_reconnects,\n        ...rest_options\n      },\n      generate_request_id\n    );\n  }\n};\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNQO0FBQ2xCO0FBQ0Q7O0FBRTFCO0FBQ0E7QUFDQSxhQUFhLDBDQUFhO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyx1REFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVpRjtBQUNqRjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXJjLWZ4LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL2Rpc3QvaW5kZXgubWpzPzNhNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdlYlNvY2tldEltcGwsIHsgV2ViU29ja2V0U2VydmVyIH0gZnJvbSAnd3MnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgdXJsIGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IHYxIH0gZnJvbSAndXVpZCc7XG5cbi8vIHNyYy9saWIvY2xpZW50L3dlYnNvY2tldC50c1xuZnVuY3Rpb24gV2ViU29ja2V0KGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBXZWJTb2NrZXRJbXBsKGFkZHJlc3MsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvbGliL3V0aWxzLnRzXG52YXIgRGVmYXVsdERhdGFQYWNrID0gY2xhc3Mge1xuICBlbmNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIGRlY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9jbGllbnQudHNcbnZhciBDb21tb25DbGllbnQgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGFkZHJlc3M7XG4gIHJwY19pZDtcbiAgcXVldWU7XG4gIG9wdGlvbnM7XG4gIGF1dG9jb25uZWN0O1xuICByZWFkeTtcbiAgcmVjb25uZWN0O1xuICByZWNvbm5lY3RfdGltZXJfaWQ7XG4gIHJlY29ubmVjdF9pbnRlcnZhbDtcbiAgbWF4X3JlY29ubmVjdHM7XG4gIHJlc3Rfb3B0aW9ucztcbiAgY3VycmVudF9yZWNvbm5lY3RzO1xuICBnZW5lcmF0ZV9yZXF1ZXN0X2lkO1xuICBzb2NrZXQ7XG4gIHdlYlNvY2tldEZhY3Rvcnk7XG4gIGRhdGFQYWNrO1xuICAvKipcbiAgKiBJbnN0YW50aWF0ZSBhIENsaWVudCBjbGFzcy5cbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge3dlYlNvY2tldEZhY3Rvcnl9IHdlYlNvY2tldEZhY3RvcnkgLSBmYWN0b3J5IG1ldGhvZCBmb3IgV2ViU29ja2V0XG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSB1cmwgdG8gYSB3ZWJzb2NrZXQgc2VydmVyXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBvcHRpb25zIG9iamVjdCB3aXRoIHJlY29ubmVjdCBwYXJhbWV0ZXJzXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZ2VuZXJhdGVfcmVxdWVzdF9pZCAtIGN1c3RvbSBnZW5lcmF0aW9uIHJlcXVlc3QgSWRcbiAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICogQHJldHVybiB7Q29tbW9uQ2xpZW50fVxuICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzID0gXCJ3czovL2xvY2FsaG9zdDo4MDgwXCIsIHtcbiAgICBhdXRvY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3RfaW50ZXJ2YWwgPSAxZTMsXG4gICAgbWF4X3JlY29ubmVjdHMgPSA1LFxuICAgIC4uLnJlc3Rfb3B0aW9uc1xuICB9ID0ge30sIGdlbmVyYXRlX3JlcXVlc3RfaWQsIGRhdGFQYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgIHRoaXMucXVldWUgPSB7fTtcbiAgICB0aGlzLnJwY19pZCA9IDA7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmF1dG9jb25uZWN0ID0gYXV0b2Nvbm5lY3Q7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMucmVjb25uZWN0ID0gcmVjb25uZWN0O1xuICAgIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkID0gdm9pZCAwO1xuICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gcmVjb25uZWN0X2ludGVydmFsO1xuICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0cztcbiAgICB0aGlzLnJlc3Rfb3B0aW9ucyA9IHJlc3Rfb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkID0gZ2VuZXJhdGVfcmVxdWVzdF9pZCB8fCAoKCkgPT4gdHlwZW9mIHRoaXMucnBjX2lkID09PSBcIm51bWJlclwiID8gKyt0aGlzLnJwY19pZCA6IE51bWJlcih0aGlzLnJwY19pZCkgKyAxKTtcbiAgICBpZiAoIWRhdGFQYWNrKSB0aGlzLmRhdGFQYWNrID0gbmV3IERlZmF1bHREYXRhUGFjaygpO1xuICAgIGVsc2UgdGhpcy5kYXRhUGFjayA9IGRhdGFQYWNrO1xuICAgIGlmICh0aGlzLmF1dG9jb25uZWN0KVxuICAgICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdDogdGhpcy5yZWNvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgICAuLi50aGlzLnJlc3Rfb3B0aW9uc1xuICAgICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQ29ubmVjdHMgdG8gYSBkZWZpbmVkIHNlcnZlciBpZiBub3QgY29ubmVjdGVkIGFscmVhZHkuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHJldHVybjtcbiAgICB0aGlzLl9jb25uZWN0KHRoaXMuYWRkcmVzcywge1xuICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgcmVjb25uZWN0X2ludGVydmFsOiB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBDYWxscyBhIHJlZ2lzdGVyZWQgUlBDIG1ldGhvZCBvbiBzZXJ2ZXIuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIFJQQyByZXBseSB0aW1lb3V0IHZhbHVlXG4gICogQHBhcmFtIHtPYmplY3R9IHdzX29wdHMgLSBvcHRpb25zIHBhc3NlZCB0byB3c1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGNhbGwobWV0aG9kLCBwYXJhbXMsIHRpbWVvdXQsIHdzX29wdHMpIHtcbiAgICBpZiAoIXdzX29wdHMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRpbWVvdXQpIHtcbiAgICAgIHdzX29wdHMgPSB0aW1lb3V0O1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICBjb25zdCBycGNfaWQgPSB0aGlzLmdlbmVyYXRlX3JlcXVlc3RfaWQobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCB2b2lkIDAsXG4gICAgICAgIGlkOiBycGNfaWRcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKG1lc3NhZ2UpLCB3c19vcHRzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5xdWV1ZVtycGNfaWRdID0geyBwcm9taXNlOiBbcmVzb2x2ZSwgcmVqZWN0XSB9O1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIHRoaXMucXVldWVbcnBjX2lkXS50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZVtycGNfaWRdO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJlcGx5IHRpbWVvdXRcIikpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBMb2dpbnMgd2l0aCB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIExvZ2luIGNyZWRlbnRpYWxzIG9iamVjdFxuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGFzeW5jIGxvZ2luKHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMubG9naW5cIiwgcGFyYW1zKTtcbiAgICBpZiAoIXJlc3ApIHRocm93IG5ldyBFcnJvcihcImF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiKTtcbiAgICByZXR1cm4gcmVzcDtcbiAgfVxuICAvKipcbiAgKiBGZXRjaGVzIGEgbGlzdCBvZiBjbGllbnQncyBtZXRob2RzIHJlZ2lzdGVyZWQgb24gc2VydmVyLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtBcnJheX1cbiAgKi9cbiAgYXN5bmMgbGlzdE1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsbChcIl9fbGlzdE1ldGhvZHNcIik7XG4gIH1cbiAgLyoqXG4gICogU2VuZHMgYSBKU09OLVJQQyAyLjAgbm90aWZpY2F0aW9uIHRvIHNlcnZlci5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIFJQQyBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBvcHRpb25hbCBtZXRob2QgcGFyYW1ldGVyc1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIG5vdGlmeShtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUobWVzc2FnZSksIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBTdWJzY3JpYmVzIGZvciBhIGRlZmluZWQgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudCAtIGV2ZW50IG5hbWVcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICogQHRocm93cyB7RXJyb3J9XG4gICovXG4gIGFzeW5jIHN1YnNjcmliZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIGV2ZW50ID0gW2V2ZW50XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMub25cIiwgZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgJiYgcmVzdWx0W2V2ZW50XSAhPT0gXCJva1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkZhaWxlZCBzdWJzY3JpYmluZyB0byBhbiBldmVudCAnXCIgKyBldmVudCArIFwiJyB3aXRoOiBcIiArIHJlc3VsdFtldmVudF1cbiAgICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgKiBVbnN1YnNjcmliZXMgZnJvbSBhIGRlZmluZWQgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudCAtIGV2ZW50IG5hbWVcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICogQHRocm93cyB7RXJyb3J9XG4gICovXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikgZXZlbnQgPSBbZXZlbnRdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5vZmZcIiwgZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgJiYgcmVzdWx0W2V2ZW50XSAhPT0gXCJva1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHVuc3Vic2NyaWJpbmcgZnJvbSBhbiBldmVudCB3aXRoOiBcIiArIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgKiBDbG9zZXMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBncmFjZWZ1bGx5LlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIHNvY2tldCBjbG9zZSBjb2RlXG4gICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSBvcHRpb25hbCBkYXRhIHRvIGJlIHNlbnQgYmVmb3JlIGNsb3NpbmdcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHRoaXMuc29ja2V0LmNsb3NlKGNvZGUgfHwgMWUzLCBkYXRhKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGUgLyBkaXNhYmxlIGF1dG9tYXRpYyByZWNvbm5lY3Rpb24uXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVjb25uZWN0IC0gZW5hYmxlIC8gZGlzYWJsZSByZWNvbm5lY3Rpb25cbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIHNldEF1dG9SZWNvbm5lY3QocmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QgPSByZWNvbm5lY3Q7XG4gIH1cbiAgLyoqXG4gICogU2V0IHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsIC0gcmVjb25uZWN0aW9uIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0UmVjb25uZWN0SW50ZXJ2YWwoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCA9IGludGVydmFsO1xuICB9XG4gIC8qKlxuICAqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gbWF4X3JlY29ubmVjdHMgLSBtYXhpbXVtIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0TWF4UmVjb25uZWN0cyhtYXhfcmVjb25uZWN0cykge1xuICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0cztcbiAgfVxuICAvKipcbiAgKiBHZXQgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBtYWRlLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICovXG4gIGdldEN1cnJlbnRSZWNvbm5lY3RzKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cztcbiAgfVxuICAvKipcbiAgKiBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7TnVtYmVyfSBtYXhpbXVtIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAqL1xuICBnZXRNYXhSZWNvbm5lY3RzKCkge1xuICAgIHJldHVybiB0aGlzLm1heF9yZWNvbm5lY3RzO1xuICB9XG4gIC8qKlxuICAqIENoZWNrIGlmIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0LlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHJlY29ubmVjdGlvbiBpcyBpbiBwcm9ncmVzc1xuICAqL1xuICBpc1JlY29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgIT09IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgKiBDaGVjayBpZiB0aGUgY2xpZW50IHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3Qgb24gdGhlIG5leHQgY2xvc2UgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcmVjb25uZWN0aW9uIHdpbGwgYmUgYXR0ZW1wdGVkXG4gICovXG4gIHdpbGxSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25uZWN0ICYmICh0aGlzLm1heF9yZWNvbm5lY3RzID09PSAwIHx8IHRoaXMuY3VycmVudF9yZWNvbm5lY3RzIDwgdGhpcy5tYXhfcmVjb25uZWN0cyk7XG4gIH1cbiAgLyoqXG4gICogQ29ubmVjdGlvbi9NZXNzYWdlIGhhbmRsZXIuXG4gICogQG1ldGhvZFxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBXZWJTb2NrZXQgQVBJIGFkZHJlc3NcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIG9wdGlvbnMgb2JqZWN0XG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfY29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0X3RpbWVyX2lkKTtcbiAgICB0aGlzLnNvY2tldCA9IHRoaXMud2ViU29ja2V0RmFjdG9yeShhZGRyZXNzLCBvcHRpb25zKTtcbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcIm9wZW5cIik7XG4gICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgfSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHsgZGF0YTogbWVzc2FnZSB9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmRhdGFQYWNrLmRlY29kZShtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5vdGlmaWNhdGlvbiAmJiB0aGlzLmxpc3RlbmVycyhtZXNzYWdlLm5vdGlmaWNhdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMobWVzc2FnZS5wYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG1lc3NhZ2Uubm90aWZpY2F0aW9uKTtcbiAgICAgICAgY29uc3QgYXJncyA9IFttZXNzYWdlLm5vdGlmaWNhdGlvbl07XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSBhcmdzLnB1c2gobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBhcmFtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGFyZ3MucHVzaChtZXNzYWdlLnBhcmFtc1tpXSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZT8ucGFyYW1zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UgPT09IFwicmVzdWx0XCIgaW4gbWVzc2FnZSlcbiAgICAgICAgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzFdKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTZXJ2ZXIgcmVzcG9uc2UgbWFsZm9ybWVkLiBSZXNwb25zZSBtdXN0IGluY2x1ZGUgZWl0aGVyIFwicmVzdWx0XCIgb3IgXCJlcnJvclwiLCBidXQgbm90IGJvdGguJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGlmICh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpO1xuICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IpIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVsxXShtZXNzYWdlLmVycm9yKTtcbiAgICAgIGVsc2UgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzBdKG1lc3NhZ2UucmVzdWx0KTtcbiAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICh7IGNvZGUsIHJlYXNvbiB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFkeSlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmVtaXQoXCJjbG9zZVwiLCBjb2RlLCByZWFzb24pLCAwKTtcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc29ja2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKGNvZGUgPT09IDFlMykgcmV0dXJuO1xuICAgICAgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMrKztcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdCAmJiAodGhpcy5tYXhfcmVjb25uZWN0cyA+IHRoaXMuY3VycmVudF9yZWNvbm5lY3RzIHx8IHRoaXMubWF4X3JlY29ubmVjdHMgPT09IDApKVxuICAgICAgICB0aGlzLnJlY29ubmVjdF90aW1lcl9pZCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gdGhpcy5fY29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSxcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbFxuICAgICAgICApO1xuICAgICAgZWxzZSBpZiAodGhpcy5yZWNvbm5lY3QgJiYgdGhpcy5tYXhfcmVjb25uZWN0cyA+IDAgJiYgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgPj0gdGhpcy5tYXhfcmVjb25uZWN0cykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZW1pdChcIm1heF9yZWNvbm5lY3RzX3JlYWNoZWRcIiwgY29kZSwgcmVhc29uKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgU2VydmVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBuYW1lc3BhY2VzO1xuICBkYXRhUGFjaztcbiAgd3NzO1xuICAvKipcbiAgKiBJbnN0YW50aWF0ZSBhIFNlcnZlciBjbGFzcy5cbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIGNvbnN0cnVjdG9yJ3MgcGFyYW1ldGVycyB3aXRoIHJwY1xuICAqIEBwYXJhbSB7RGF0YVBhY2t9IGRhdGFQYWNrIC0gZGF0YSBwYWNrIGNvbnRhaW5zIGVuY29kZXIgYW5kIGRlY29kZXJcbiAgKiBAcmV0dXJuIHtTZXJ2ZXJ9IC0gcmV0dXJucyBhIG5ldyBTZXJ2ZXIgaW5zdGFuY2VcbiAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgZGF0YVBhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZXNwYWNlcyA9IHt9O1xuICAgIGlmICghZGF0YVBhY2spIHRoaXMuZGF0YVBhY2sgPSBuZXcgRGVmYXVsdERhdGFQYWNrKCk7XG4gICAgZWxzZSB0aGlzLmRhdGFQYWNrID0gZGF0YVBhY2s7XG4gICAgdGhpcy53c3MgPSBuZXcgV2ViU29ja2V0U2VydmVyKG9wdGlvbnMpO1xuICAgIHRoaXMud3NzLm9uKFwibGlzdGVuaW5nXCIsICgpID0+IHRoaXMuZW1pdChcImxpc3RlbmluZ1wiKSk7XG4gICAgdGhpcy53c3Mub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQsIHJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IHUgPSB1cmwucGFyc2UocmVxdWVzdC51cmwsIHRydWUpO1xuICAgICAgY29uc3QgbnMgPSB1LnBhdGhuYW1lO1xuICAgICAgaWYgKHUucXVlcnkuc29ja2V0X2lkKSBzb2NrZXQuX2lkID0gdS5xdWVyeS5zb2NrZXRfaWQ7XG4gICAgICBlbHNlIHNvY2tldC5faWQgPSB2MSgpO1xuICAgICAgc29ja2V0W1wiX2F1dGhlbnRpY2F0ZWRcIl0gPSBmYWxzZTtcbiAgICAgIHNvY2tldC5vbihcImVycm9yXCIsIChlcnJvcikgPT4gdGhpcy5lbWl0KFwic29ja2V0LWVycm9yXCIsIHNvY2tldCwgZXJyb3IpKTtcbiAgICAgIHNvY2tldC5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmRlbGV0ZShzb2NrZXQuX2lkKTtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cykpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW2V2ZW50XS5zb2NrZXRzLmluZGV4T2YoXG4gICAgICAgICAgICBzb2NrZXQuX2lkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMClcbiAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW2V2ZW50XS5zb2NrZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGlvblwiLCBzb2NrZXQpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHRoaXMuX2dlbmVyYXRlTmFtZXNwYWNlKG5zKTtcbiAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5zZXQoc29ja2V0Ll9pZCwgc29ja2V0KTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25cIiwgc29ja2V0LCByZXF1ZXN0KTtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVSUEMoc29ja2V0LCBucyk7XG4gICAgfSk7XG4gICAgdGhpcy53c3Mub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gIH1cbiAgLyoqXG4gICogUmVnaXN0ZXJzIGFuIFJQQyBtZXRob2QuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGEgY2FsbGVlIGZ1bmN0aW9uXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIHJldHVybnMgYW4gSU1ldGhvZCBvYmplY3RcbiAgKi9cbiAgcmVnaXN0ZXIobmFtZSwgZm4sIG5zID0gXCIvXCIpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHRoaXMuX2dlbmVyYXRlTmFtZXNwYWNlKG5zKTtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdID0ge1xuICAgICAgZm4sXG4gICAgICBwcm90ZWN0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvdGVjdGVkOiAoKSA9PiB0aGlzLl9tYWtlUHJvdGVjdGVkTWV0aG9kKG5hbWUsIG5zKSxcbiAgICAgIHB1YmxpYzogKCkgPT4gdGhpcy5fbWFrZVB1YmxpY01ldGhvZChuYW1lLCBucylcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIFNldHMgYW4gYXV0aCBtZXRob2QuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gYW4gYXJiaXRyYXJ5IGF1dGggbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRBdXRoKGZuLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5yZWdpc3RlcihcInJwYy5sb2dpblwiLCBmbiwgbnMpO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIFJQQyBtZXRob2QgYXMgcHJvdGVjdGVkLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHJvdGVjdGVkTWV0aG9kKG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdLnByb3RlY3RlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gUlBDIG1ldGhvZCBhcyBwdWJsaWMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQdWJsaWNNZXRob2QobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbmFtZV0ucHJvdGVjdGVkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gZXZlbnQgYXMgcHJvdGVjdGVkLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGV2ZW50IG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQcm90ZWN0ZWRFdmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0ucHJvdGVjdGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgKiBNYXJrcyBhbiBldmVudCBhcyBwdWJsaWMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gZXZlbnQgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfbWFrZVB1YmxpY0V2ZW50KG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5wcm90ZWN0ZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBSZW1vdmVzIGEgbmFtZXNwYWNlIGFuZCBjbG9zZXMgYWxsIGNvbm5lY3Rpb25zXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgY2xvc2VOYW1lc3BhY2UobnMpIHtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgIGRlbGV0ZSBuYW1lc3BhY2UucnBjX21ldGhvZHM7XG4gICAgICBkZWxldGUgbmFtZXNwYWNlLmV2ZW50cztcbiAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIG5hbWVzcGFjZS5jbGllbnRzLnZhbHVlcygpKSBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBDcmVhdGVzIGEgbmV3IGV2ZW50IHRoYXQgY2FuIGJlIGVtaXR0ZWQgdG8gY2xpZW50cy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBldmVudCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIHJldHVybnMgYW4gSUV2ZW50IG9iamVjdFxuICAqL1xuICBldmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdO1xuICAgICAgaWYgKGluZGV4ICE9PSB2b2lkIDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSByZWdpc3RlcmVkIGV2ZW50ICR7bnN9JHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXSA9IHtcbiAgICAgIHNvY2tldHM6IFtdLFxuICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5vbihuYW1lLCAoLi4ucGFyYW1zKSA9PiB7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0gaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtc1swXTtcbiAgICAgIGZvciAoY29uc3Qgc29ja2V0X2lkIG9mIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnNvY2tldHMpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpO1xuICAgICAgICBpZiAoIXNvY2tldCkgY29udGludWU7XG4gICAgICAgIHNvY2tldC5zZW5kKFxuICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogbmFtZSxcbiAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RlY3RlZDogKCkgPT4gdGhpcy5fbWFrZVByb3RlY3RlZEV2ZW50KG5hbWUsIG5zKSxcbiAgICAgIHB1YmxpYzogKCkgPT4gdGhpcy5fbWFrZVB1YmxpY0V2ZW50KG5hbWUsIG5zKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyBhIHJlcXVlc3RlZCBuYW1lc3BhY2Ugb2JqZWN0XG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIG5hbWVzcGFjZSBvYmplY3RcbiAgKi9cbiAgb2YobmFtZSkge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25hbWVdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShuYW1lKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgLy8gc2VsZi5yZWdpc3RlciBjb252ZW5pZW5jZSBtZXRob2RcbiAgICAgIHJlZ2lzdGVyKGZuX25hbWUsIGZuKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3QgcHJvdmlkZSBleGFjdGx5IHR3byBhcmd1bWVudHNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZm5fbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHNlbGYucmVnaXN0ZXIoZm5fbmFtZSwgZm4sIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIHNlbGYuZXZlbnQgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICBldmVudChldl9uYW1lKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3QgcHJvdmlkZSBleGFjdGx5IG9uZSBhcmd1bWVudFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBldl9uYW1lICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZXZlbnQoZXZfbmFtZSwgbmFtZSk7XG4gICAgICB9LFxuICAgICAgLy8gc2VsZi5ldmVudExpc3QgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICBnZXQgZXZlbnRMaXN0KCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VsZi5uYW1lc3BhY2VzW25hbWVdLmV2ZW50cyk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIEVtaXRzIGEgc3BlY2lmaWVkIGV2ZW50IHRvIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBldmVudCBuYW1lXG4gICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyAtIGV2ZW50IHBhcmFtZXRlcnNcbiAgICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAgKi9cbiAgICAgIGVtaXQoZXZlbnQsIC4uLnBhcmFtcykge1xuICAgICAgICBjb25zdCBuc0V2ZW50ID0gc2VsZi5uYW1lc3BhY2VzW25hbWVdLmV2ZW50c1tldmVudF07XG4gICAgICAgIGlmIChuc0V2ZW50KVxuICAgICAgICAgIGZvciAoY29uc3Qgc29ja2V0X2lkIG9mIG5zRXZlbnQuc29ja2V0cykge1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMuZ2V0KHNvY2tldF9pZCk7XG4gICAgICAgICAgICBpZiAoIXNvY2tldCkgY29udGludWU7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChcbiAgICAgICAgICAgICAgc2VsZi5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogZXZlbnQsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICogUmV0dXJucyBhIG5hbWUgb2YgdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBraW5kIGNvbnN0YW50XG4gICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICovXG4gICAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBoYXNoIG9mIHdlYnNvY2tldCBvYmplY3RzIGNvbm5lY3RlZCB0byB0aGlzIG5hbWVzcGFjZS5cbiAgICAgICogQGlubmVyXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgKi9cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0X2lkcyA9IFsuLi5zZWxmLm5hbWVzcGFjZXNbbmFtZV0uY2xpZW50cy5rZXlzKCldO1xuICAgICAgICByZXR1cm4gc29ja2V0X2lkcy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgY3VycikgPT4gKHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIFtjdXJyXTogc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMuZ2V0KGN1cnIpXG4gICAgICAgICAgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgY2xpZW50IHVuaXF1ZSBpZGVudGlmaWVycyBjb25uZWN0ZWQgdG8gdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgKi9cbiAgICAgIGNsaWVudHMoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLm5hbWVzcGFjZXNbbmFtZV07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBMaXN0cyBhbGwgY3JlYXRlZCBldmVudHMgaW4gYSBnaXZlbiBuYW1lc3BhY2UuIERlZmF1bHRzIHRvIFwiL1wiLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmVhZG9ubHlcbiAgKiBAcmV0dXJuIHtBcnJheX0gLSByZXR1cm5zIGEgbGlzdCBvZiBjcmVhdGVkIGV2ZW50c1xuICAqL1xuICBldmVudExpc3QobnMgPSBcIi9cIikge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXSkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cyk7XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlcyBhIEpTT04tUlBDIDIuMCBjb21wbGlhbnQgZXJyb3JcbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgLSBpbmRpY2F0ZXMgdGhlIGVycm9yIHR5cGUgdGhhdCBvY2N1cnJlZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gcHJvdmlkZXMgYSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGEgLSBkZXRhaWxzIGNvbnRhaW5pbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3JcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICovXG4gIGNyZWF0ZUVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkYXRhOiBkYXRhIHx8IG51bGxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIENsb3NlcyB0aGUgc2VydmVyIGFuZCB0ZXJtaW5hdGVzIGFsbCBjbGllbnRzLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53c3MuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogSGFuZGxlcyBhbGwgV2ViU29ja2V0IEpTT04gUlBDIDIuMCByZXF1ZXN0cy5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXQgLSB3cyBzb2NrZXQgaW5zdGFuY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9oYW5kbGVSUEMoc29ja2V0LCBucyA9IFwiL1wiKSB7XG4gICAgc29ja2V0Lm9uKFwibWVzc2FnZVwiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgbXNnX29wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgbXNnX29wdGlvbnMuYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHJldHVybjtcbiAgICAgIGxldCBwYXJzZWREYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkRGF0YSA9IHRoaXMuZGF0YVBhY2suZGVjb2RlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKFxuICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNzAwLCBlcnJvci50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbXNnX29wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZERhdGEpKSB7XG4gICAgICAgIGlmICghcGFyc2VkRGF0YS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKFxuICAgICAgICAgICAgdGhpcy5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgYXJyYXlcIiksXG4gICAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1zZ19vcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJzZWREYXRhKSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgdGhpcy5fcnVuTWV0aG9kKG1lc3NhZ2UsIHNvY2tldC5faWQsIG5zKTtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlMikgY29udGludWU7XG4gICAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVzcG9uc2UyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKHJlc3BvbnNlcyksIG1zZ19vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnVuTWV0aG9kKHBhcnNlZERhdGEsIHNvY2tldC5faWQsIG5zKTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHJldHVybjtcbiAgICAgIHJldHVybiBzb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShyZXNwb25zZSksIG1zZ19vcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBSdW5zIGEgZGVmaW5lZCBSUEMgbWV0aG9kLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2UgLSBhIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgKiBAcGFyYW0ge09iamVjdH0gc29ja2V0X2lkIC0gdXNlcidzIHNvY2tldCBpZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZXMgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gICovXG4gIGFzeW5jIF9ydW5NZXRob2QobWVzc2FnZSwgc29ja2V0X2lkLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwKSxcbiAgICAgICAgaWQ6IG51bGxcbiAgICAgIH07XG4gICAgaWYgKG1lc3NhZ2UuanNvbnJwYyAhPT0gXCIyLjBcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDAsIFwiSW52YWxpZCBKU09OIFJQQyB2ZXJzaW9uXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmICghbWVzc2FnZS5tZXRob2QpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAyLCBcIk1ldGhvZCBub3Qgc3BlY2lmaWVkXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tZXRob2QgIT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgbWV0aG9kIG5hbWVcIiksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgaWYgKG1lc3NhZ2UucGFyYW1zICYmIHR5cGVvZiBtZXNzYWdlLnBhcmFtcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDApLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMub25cIikge1xuICAgICAgaWYgKCFtZXNzYWdlLnBhcmFtcylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzJlMyksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICAgICAgY29uc3QgZXZlbnRfbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cyk7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBldmVudF9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwicHJvdmlkZWQgZXZlbnQgaW52YWxpZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0ucHJvdGVjdGVkID09PSB0cnVlICYmIG5hbWVzcGFjZS5jbGllbnRzLmdldChzb2NrZXRfaWQpW1wiX2F1dGhlbnRpY2F0ZWRcIl0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA2KSxcbiAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldF9pbmRleCA9IG5hbWVzcGFjZS5ldmVudHNbZXZlbnRfbmFtZXNbaW5kZXhdXS5zb2NrZXRzLmluZGV4T2Yoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKHNvY2tldF9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gc3Vic2NyaWJlZCB0byBldmVudFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzcGFjZS5ldmVudHNbZXZlbnRfbmFtZXNbaW5kZXhdXS5zb2NrZXRzLnB1c2goc29ja2V0X2lkKTtcbiAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwib2tcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5vZmZcIikge1xuICAgICAgaWYgKCFtZXNzYWdlLnBhcmFtcylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzJlMyksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICByZXN1bHRzW25hbWVdID0gXCJwcm92aWRlZCBldmVudCBpbnZhbGlkXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5zb2NrZXRzLmluZGV4T2Yoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcIm5vdCBzdWJzY3JpYmVkXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0uc29ja2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXN1bHRzW25hbWVdID0gXCJva1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgcmVzdWx0OiByZXN1bHRzLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXRob2QgPT09IFwicnBjLmxvZ2luXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA0KSxcbiAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDEpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgIGlmICh0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW21lc3NhZ2UubWV0aG9kXS5wcm90ZWN0ZWQgPT09IHRydWUgJiYgdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpW1wiX2F1dGhlbnRpY2F0ZWRcIl0gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA1KSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0uZm4oXG4gICAgICAgIG1lc3NhZ2UucGFyYW1zLFxuICAgICAgICBzb2NrZXRfaWRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkgcmV0dXJuO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgY29kZTogLTMyZTMsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5uYW1lLFxuICAgICAgICAgICAgZGF0YTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBpZDogbWVzc2FnZS5pZFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlLmlkKSByZXR1cm47XG4gICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5sb2dpblwiICYmIHJlc3BvbnNlID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpO1xuICAgICAgc1tcIl9hdXRoZW50aWNhdGVkXCJdID0gdHJ1ZTtcbiAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5zZXQoc29ja2V0X2lkLCBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICByZXN1bHQ6IHJlc3BvbnNlLFxuICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIEdlbmVyYXRlIGEgbmV3IG5hbWVzcGFjZSBzdG9yZS5cbiAgKiBBbHNvIHByZXJlZ2lzdGVyIHNvbWUgc3BlY2lhbCBuYW1lc3BhY2UgbWV0aG9kcy5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAqL1xuICBfZ2VuZXJhdGVOYW1lc3BhY2UobmFtZSkge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuYW1lXSA9IHtcbiAgICAgIHJwY19tZXRob2RzOiB7XG4gICAgICAgIF9fbGlzdE1ldGhvZHM6IHtcbiAgICAgICAgICBmbjogKCkgPT4gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25hbWVdLnJwY19tZXRob2RzKSxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGllbnRzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgZXZlbnRzOiB7fVxuICAgIH07XG4gIH1cbn07XG52YXIgUlBDX0VSUk9SUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgWy0zMmUzLCBcIkV2ZW50IG5vdCBwcm92aWRlZFwiXSxcbiAgWy0zMjYwMCwgXCJJbnZhbGlkIFJlcXVlc3RcIl0sXG4gIFstMzI2MDEsIFwiTWV0aG9kIG5vdCBmb3VuZFwiXSxcbiAgWy0zMjYwMiwgXCJJbnZhbGlkIHBhcmFtc1wiXSxcbiAgWy0zMjYwMywgXCJJbnRlcm5hbCBlcnJvclwiXSxcbiAgWy0zMjYwNCwgXCJQYXJhbXMgbm90IGZvdW5kXCJdLFxuICBbLTMyNjA1LCBcIk1ldGhvZCBmb3JiaWRkZW5cIl0sXG4gIFstMzI2MDYsIFwiRXZlbnQgZm9yYmlkZGVuXCJdLFxuICBbLTMyNzAwLCBcIlBhcnNlIGVycm9yXCJdXG5dKTtcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKGNvZGUsIGRldGFpbHMpIHtcbiAgY29uc3QgZXJyb3IgPSB7XG4gICAgY29kZSxcbiAgICBtZXNzYWdlOiBSUENfRVJST1JTLmdldChjb2RlKSB8fCBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG4gIH07XG4gIGlmIChkZXRhaWxzKSBlcnJvcltcImRhdGFcIl0gPSBkZXRhaWxzO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIENsaWVudCA9IGNsYXNzIGV4dGVuZHMgQ29tbW9uQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoYWRkcmVzcyA9IFwid3M6Ly9sb2NhbGhvc3Q6ODA4MFwiLCB7XG4gICAgYXV0b2Nvbm5lY3QgPSB0cnVlLFxuICAgIHJlY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0X2ludGVydmFsID0gMWUzLFxuICAgIG1heF9yZWNvbm5lY3RzID0gNSxcbiAgICAuLi5yZXN0X29wdGlvbnNcbiAgfSA9IHt9LCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKSB7XG4gICAgc3VwZXIoXG4gICAgICBXZWJTb2NrZXQsXG4gICAgICBhZGRyZXNzLFxuICAgICAge1xuICAgICAgICBhdXRvY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0LFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzLFxuICAgICAgICAuLi5yZXN0X29wdGlvbnNcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZV9yZXF1ZXN0X2lkXG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgQ2xpZW50LCBDb21tb25DbGllbnQsIERlZmF1bHREYXRhUGFjaywgU2VydmVyLCBXZWJTb2NrZXQsIGNyZWF0ZUVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/dist/index.mjs\n");

/***/ })

};
;